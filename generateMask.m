function [maskuse]= generateMask(circlength,degPerPix,sizeX,sizeY,black,white,posX,posY,cpx_cm,cpy_cm,azcp,elcp,szXcm,szYcm)%%% generate a "mask" for drifting or counterphase gratings%%% part of mask is transparent -- a circle through which to see underlying%%% stimuli. NOTE: input is compatible with data from "hand mapping" %%% (position in degrees)%%% %%% circle parameters:%%% radius = length/2%%% position (degrees) = (posX, PosY)%%%%%% code inspired by: http://peterscarfe.com/contrastSpiralTextureDemo.html%%% MCD 02/27/2015% Define mask (non-transparent) colorgray = 0.5*(white+black);% generate matrix size of screen[x, y] = meshgrid(floor(-sizeX/2):floor(sizeX/2), floor(-sizeY/2):floor(sizeY/2));[sy, sx] = size(x);% Convert spot position (degree) into pixelspx = floor((posX - azcp)/degPerPix+cpx_cm/szXcm*sizeX); % position X in pixelspy = floor((posY-elcp)/(-degPerPix)+cpy_cm/szYcm*sizeY); % position Y in pixels% If spot is not in center, determine how far you will move it (see end)addx = px-floor(sx/2);addy = py-floor(sy/2);% make two-layer mask; second layer is alpha level--transparence% start by putting spot in center of screenmaskuse = ones(sy, sx, 2) .* gray; rad = circlength/(degPerPix*2); % length(deg)*deg/pix*1/2 = # pixels for radz = sqrt(x.^2 + y.^2);z = z(:);% start with inner area (fade across 10% of rad)dr = floor(0.25*rad);numdivs = floor(rad/5);if numdivs < 10    numdivs = 10;endvals = linspace(rad-dr,rad,numdivs);colordiv = floor(linspace(0,white,numdivs));tmpout = zeros(size(z));for g = 1:length(vals)    tst = z > vals(g);    tmpout(tst) = tst(tst)*colordiv(g);end% tst = z > rad; % make 0 center part; 1 outside parts; (0 = transparent)% tst = tst*white;centered = reshape(tmpout,sy,sx);% center the transparancy on (xpos,ypos)nw = white*ones(sy+abs(addy),sx+abs(addx));if addx > 0 && addy > 0    nw(abs(addy)+1:end,abs(addx)+1:end) = centered;    m = nw(1:sy,1:sx);elseif addx < 0 && addy < 0    nw(1:sy,1:sx) = centered;    m = nw(abs(addy)+1:end,abs(addx)+1:end);elseif addx > 0 && addy < 0    nw(1:sy,abs(addx)+1:end) = centered ;    m = nw(abs(addy)+1:end,1:sx);else % addx < 0 && addy > 0    nw(abs(addy)+1:end,1:sx) = centered ;    m = nw(1:sy,abs(addx)+1:end);endmaskuse(:,:,2) = m;